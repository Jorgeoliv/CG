void drawCube(float side, int divisions) {
    const float divisionSide = side/divisions;      // comprimento do lado de cada divisão
    const float max = side/2, min = -max;           // valor máximo/mínimo que a variável pode tomar
    float i1=min, j1=min, i2, j2;
    
    for(int i=1; i<=divisions; i++){
        i2 = min + i*divisionSide;

        for(int j=1; j<=divisions; j++){
            j2 = min + j*divisionSide;

            // Invariante de ciclo: i2 <=> i1 + divSide e j2 <=> j1 + divSide

            glBegin(GL_TRIANGLES);
            glColor3f(0.0f, 0.0f, 1.0f);

            // base
            glVertex3f(i1, min, j1);
            glVertex3f(i2, min, j2);
            glVertex3f(i1, min, j2);
            glVertex3f(i1, min, j1);
            glVertex3f(i2, min, j1);
            glVertex3f(i2, min, j2);

            // topo
            glVertex3f(i1, max, j1);
            glVertex3f(i1, max, j2);
            glVertex3f(i2, max, j2);
            glVertex3f(i1, max, j1);
            glVertex3f(i2, max, j2);
            glVertex3f(i2, max, j1);

            // laterais
            glVertex3f(min, i1, j1);
            glVertex3f(min, i1, j2);
            glVertex3f(min, i2, j2);
            glVertex3f(min, i1, j1);
            glVertex3f(min, i2, j2);
            glVertex3f(min, i2, j1);

            glVertex3f(max, i1, j1);
            glVertex3f(max, i2, j1);
            glVertex3f(max, i2, j2);
            glVertex3f(max, i1, j1);
            glVertex3f(max, i2, j2);
            glVertex3f(max, i1, j2);

            glVertex3f(j1, i1, min);
            glVertex3f(j1, i2, min);
            glVertex3f(j2, i2, min);
            glVertex3f(j1, i1, min);
            glVertex3f(j2, i2, min);
            glVertex3f(j2, i1, min);

            glVertex3f(j1, i1, max);
            glVertex3f(j2, i1, max);
            glVertex3f(j2, i2, max);
            glVertex3f(j1, i1, max);
            glVertex3f(j2, i2, max);
            glVertex3f(j1, i2, max);

            glEnd();

            // printf("i1=%f, j1=%f, i2=%f, j2=%f \n", i1, i2, j1, j2);

            j1 = j2;    // equivalente a j1 += divSide (j2 = j1 + divSide)
        }
        j1 = min;   // reiniciar a variável para percorrer a camada seguinte
        i1 = i2;    // equivalente a i1 += divSide (i2 = i1 + divSide)
    }
}