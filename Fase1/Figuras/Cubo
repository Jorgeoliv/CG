void drawCube(float side, int divisions) {
    float divisionSide = side/divisions;        // comprimento do lado de cada divisão
    float min = -side/2;                        // valor mínimo que a variável pode tomar
    float max = -min;                           // valor máximo que a variável pode tomar
    float x1i=min, y1i=min, x1j=min, z1j=min;   // i/j -> indicador do ciclo em que vão iterar (interno ou externo)
    float x2i, y2i, x2j, z2j;                   // a1/a2 -> indicador quem está antes/depois relativamente ao eixo a.
                                                // por exemplo x1 está imediatamente antes de x2 relativamente ao eixo x
                                                // por exemplo z1 está imediatamente antes de z2 relativamente ao eixo z
                                                // no fim do ciclo x1 toma o valor de x2 e x2 recebe o valor imediatamente depois

    for(int i=1; i<=divisions; i++){
        x2i = min + i*divisionSide;
        y2i = min + i*divisionSide;

        for(int j=1; j<=divisions; j++){
            x2j = min + j*divisionSide;
            z2j = min + j*divisionSide;

            glBegin(GL_TRIANGLES);
            glColor3f(0.0f, 0.0f, 1.0f);

            // base
            // x2i <=> x1i + divSide, x2j <=> x1j + divSide
            glVertex3f(x1i, min, z1j);
            glVertex3f(x2i, min, z2j);
            glVertex3f(x1i, min, z2j);
            glVertex3f(x1i, min, z1j);
            glVertex3f(x2i, min, z1j);
            glVertex3f(x2i, min, z2j);

            // topo
            glVertex3f(x1i, max, z1j);
            glVertex3f(x1i, max, z2j);
            glVertex3f(x2i, max, z2j);
            glVertex3f(x1i, max, z1j);
            glVertex3f(x2i, max, z2j);
            glVertex3f(x2i, max, z1j);

            // laterais
            // x2j <=> x1j + divSide, y2i <=> y1i + divSide, z2j <=> z1j + divSide
            glVertex3f(min, y1i, z1j);
            glVertex3f(min, y1i, z2j);
            glVertex3f(min, y2i, z2j);
            glVertex3f(min, y1i, z1j);
            glVertex3f(min, y2i, z2j);
            glVertex3f(min, y2i, z1j);

            glVertex3f(max, y1i, z1j);
            glVertex3f(max, y2i, z1j);
            glVertex3f(max, y2i, z2j);
            glVertex3f(max, y1i, z1j);
            glVertex3f(max, y2i, z2j);
            glVertex3f(max, y1i, z2j);

            glVertex3f(x1j, y1i, min);
            glVertex3f(x1j, y2i, min);
            glVertex3f(x2j, y2i, min);
            glVertex3f(x1j, y1i, min);
            glVertex3f(x2j, y2i, min);
            glVertex3f(x2j, y1i, min);

            glVertex3f(x1j, y1i, max);
            glVertex3f(x2j, y1i, max);
            glVertex3f(x2j, y2i, max);
            glVertex3f(x1j, y1i, max);
            glVertex3f(x2j, y2i, max);
            glVertex3f(x1j, y2i, max);

            glEnd();

            x1j = x2j; // equivalente a x1j += divSide;
            z1j = z2j; // equivalente a z1j += divSide
        }
        x1j = min; // voltar a iniciar variável
        z1j = min; // voltar a iniciar variável
        x1i = x2i; // equivalente a x1i += divSide
        y1i = y2i; // equivalente a zi1 += divSide
    }
}